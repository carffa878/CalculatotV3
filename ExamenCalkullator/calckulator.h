#pragma once
#include "Header.h"


/*cin - это входной поток.
cout - это выходной поток.
>> - прочитать из входного потока.
<< - записать в выходной поток
cin.peek() _ возвращает целочисленное представление следующего символа в буфере потока, не прочитав его

(cin >> a) при вводе значения a, если все нормально, то выражение вернет true, соответственно !(cin >> a) вернет false (неудачу)

cin.clear() очистит все биты и установит бит по умолчанию (std::ios_base::goodbit), таким образом приведя поток в рабочее состояние.

cin.get() считывает один символ, но нигде не хранит
 мн. ч. буфера́, бу́феры — это область памяти, используемая для временного
 хранения данных при вводе или выводе. Обмен данными (ввод и вывод) может происходить
 как с внешними устройствами, так и с процессами в пределах компьютера.

Стек — это структура данных, которая работает по принципу FILO 
(first in — last out; первый пришел — последний ушел)
stack <тип данных> <имя>;

*/
struct Leksema //Структура, описывающая любое число или операцию
{
	char type; // 0 для чисел, "+" для операции сложения вычитания  и так далее.
	double value; //Значение (только для чисел). У операций значение всегда "0"
};
bool Calculation(stack <Leksema>& Stack_number, stack <Leksema>& Stack_operation, Leksema& item)
{   // функция, которая производит расчеты  в аргумеете сылки передаеть адрес  на стек с операциями и стек с числами и на инцализатор item где храняться все сиволды
	//функция имеет тип bool, чтобы при возникновении какой-либо ошибки возвращать "false"
	double top_number_steck;              //переменая для  возражеть верхний елемент в стеке чисел
	double	next_number_steck;              //переменая для следуежево елемента стека
	double	resultat_operation;              //переменая для результатов операций
	top_number_steck = Stack_number.top().value; //Берется верхнее число из стека с числами
	Stack_number.pop(); // удаляется верхнее число из стека с числами
	switch (Stack_operation.top().type)    // операторатор switch проверяется тип верхней операции из стека с операциями
	{                                      // если тип верхней операции из стека с операциями сложение
	case '+':
		next_number_steck = Stack_number.top().value; //Stack_value.top() функция возращения верхнего елемент в стеке чисел
		Stack_number.pop();             // удаляется верхнее елемент с стека
		resultat_operation = top_number_steck + next_number_steck;     // результат операциии
		item.type = '0';             //  указиваем тип елемента а имено его тип это число ноль
		item.value = resultat_operation;    //значения результата
		Stack_number.push(item); // результат операции кладется обратно в стек с числами
		Stack_operation.pop();       // удаляется верхнее елемент с стека
		break;                      //Оператор break завершает выполнение ближайшего включающего цикла или условного оператора
	case '-':
		next_number_steck = Stack_number.top().value; //возращения верхнего елемент в стеке
		Stack_number.pop();                            // удаляется верхнее елемент с стека
		resultat_operation = next_number_steck - top_number_steck;   // результат операциии
		item.type = '0';                                            //  указиваем тип елемента а имено его тип это число ноль
		item.value = resultat_operation;                             //значения результата     
		Stack_number.push(item);                               // ложем результат  операции в стек с числами
		Stack_operation.pop();                                     // удаляется верхнее число со стека
		break;
	case '*':
		next_number_steck = Stack_number.top().value;     //возращения верхнего елемент в стеке
		Stack_number.pop();                               // удаляется верхнее елемент с стека
		resultat_operation = top_number_steck * next_number_steck;     // результат операциии
		item.type = '0';                                    //  указиваем тип елемента а имено его тип это число ноль
		item.value = resultat_operation;                   //значения результата  
		Stack_number.push(item);                      // ложем результат  операции в стек с числами
		Stack_operation.pop();                            // удаляется верхнее елемент с стека
		break;
	case '/':
		next_number_steck = Stack_number.top().value;   //возращения верхнего елемент в стеке
		if (top_number_steck == 0)    // если елемент равен 0 тогда ми возращаем false и выводим предупреждения для пользователя
		{
			cerr << "\nНа 0 делить нельзя!\n";
			return false;
		}
		else {
			Stack_number.pop();                          // удаляется верхнее елемент с стека
			resultat_operation = (next_number_steck / top_number_steck);   // результат операциии
			item.type = '0';                                           //  указиваем тип елемента а имено его тип это число ноль
			item.value = resultat_operation;                           //значения результата  
			Stack_number.push(item);                                // ложем результат  операции в стек с числами
			Stack_operation.pop();                                     // удаляется верхнее елемент с стека
			break; //Оператор break завершает выполнение ближайшего включающего  условного оператора
		}
	default:  // Оператор default (по умолчанию) выполняется, если ни одно значение константного выражения case не равно значению выражения и у нашому случае возращаеть false
		cerr << "\nОшибка";
		return false;
		break;//Оператор break завершает выполнение ближайшего включающего  условного оператора
	}
	return true;   // возражаем true
}


int priority(char current_character) { //функция возвращает приоритет операции: "1" для сложения и вычитания, "2" для умножения и деления и т.д.
	if (current_character == '+' || current_character == '-')  // если введений символ равен + или - то ми возражаем 1
	{
		return 1;
	}
	if (current_character == '*' || current_character == '/')   // если введений символ равен * или / то ми возражаем 2
	{
		return 2;
	}
	else   // в отальному ми возражаем 0
	{
		return 0;
	}
}
int character_check()  // функция для проверки введених пользователем символов и управления ими
{
	char current_character; //переменная, в которую будет записываться текущий обрабатываемый символ
	double value; // перемена для хранения чисел

	stack <Leksema> Stack_number; //стек с числами
	stack <Leksema> Stack_operation; //стек с операциями
	Leksema item; //объект типа Leksema для хранения всех символов
	while (1)  // бесконечний цикл 
	{
		current_character = cin.peek(); //смотрим на первый символ

		if (current_character == '\n')   // есди наш символ равен "переходу на	новая строка"
		{
			break; //Если достигнут конец строки, выходим из цикла
		}
		if (current_character == ' ')  //игнорирование пробелов
		{
			cin.ignore();  //cin.ignore()  которая используется для игнорирования или удаления одного или нескольких символов из входного буфера.
			continue;         //Оператор continue передает элемент управления в следующую итерацию
		}
		if (current_character >= '0' && current_character <= '9')  //если прочитано число
		{
			cin >> value;                // операто cin ,берет число до знака операции
			item.type = '0';              //  указиваем тип елемента   а имено его тип   ето число ноль
			item.value = value;           // его значения равно значению переменой которое ми прочитали в cin.peek()
			Stack_number.push(item); // число кладется в стек с числами
			continue;                    //Оператор continue передает элемент управления в следующую итерацию
			if (current_character == '+' || current_character == '-' || current_character == '*' || current_character == '/') // если прочитана операция
			{
				if (Stack_operation.size() == 0) // если стек с операциями пуст
				{
					item.type = current_character;  //  указиваем тип елемента а имено его тип это введение символи "+ ; - ; / ; * "
					item.value = 0;               //елементи чисел равни нулю
					Stack_operation.push(item); // операция кладется в стек с операциями
					cin.ignore();                //игнорирования символов из входного буфера.
					continue; // передает элемент управления в следующую итерацию
				}
				if (Stack_operation.size() != 0 && priority(current_character) > priority(Stack_operation.top().type)) // если стек с операциями не пуст, но приоритет текущей операции выше верхней в стеке с операциями
				{
					item.type = current_character;  //  указиваем тип елемента а имено его тип это введение символи
					item.value = 0;              //елементи чисел равни нулю
					Stack_operation.push(item); // операция кладется в стек с операциями
					cin.ignore();  //игнорирования или удаления одного или нескольких символов из входного буфера.
					continue; // передает элемент управления в следующую итерацию
				}
				if (Stack_operation.size() != 0 && priority(current_character) <= priority(Stack_operation.top().type))  //если стек с операциями не пуст, но приоритет текущей операции ниже либо равен верхней в стеке с операциями
				{
					if (Calculation(Stack_number, Stack_operation, item) == false)
					{ //если функция вернет "false", то прекращаем работу
						system("pause");  //Это специфичная для Windows команда, которая указывает ОС запустить программу паузы. Эта программа ожидает завершения и останавливает выполнение родительской программы C++. Только после завершения программы паузы продолжится исходная программа.
						return 0;
					}
					continue; // передает элемент управления в следующую итерацию
				}
			}
			if (current_character == '(') // если прочитана открывающаяся скобка
			{
				item.type = current_character; //  указиваем тип елемента а имено его тип это введение символ "("
				item.value = 0;              //елементи чисел равни нулю
				Stack_operation.push(item); // операция кладется в стек с операциями
				cin.ignore(); //игнорирования  одного или нескольких символов из входного буфера.
				continue; // передает элемент управления в следующую итерацию
			}
			if (current_character == ')')  // если прочитана закрывающаяся скобка
			{
				while (Stack_operation.top().type != '(') {
					if (Calculation(Stack_number, Stack_operation, item) == false) // если функция вернет "false", то прекращаем работу
					{
						system("pause");  //запускаем  программу паузы
						return 0;
					}
					else
					{
						continue; // передает элемент управления в следующую итерацию
					}
				}
				Stack_operation.pop();    // удаляется верхнее елемент с стека
				cin.ignore();   //игнорирования  символов из входного буфера.
				continue; // передает элемент управления в следующую итерацию
			}
			else //если прочитан какой-то странный символ
			{
				cout << "\nНеверно введено выражение!\n";
				system("pause");   //запускаем  программу паузы
				return 0;
			}
		}
		while (Stack_operation.size() != 0)  //вызываем матем. функцию до тех пор, пока в стеке с операциями не будет 0 элементов
		{
			if (Calculation(Stack_number, Stack_operation, item) == false)  //если функция вернет "false", то прекращаем работу
			{
				system("pause");   //запускаем  программу паузы
				return 0;
			}
			else
			{
				continue; // передает элемент управления в следующую итерацию
			}
		}
		cout << "\tОтвет: " << Stack_number.top().value << endl; //Выводим ответ
		return 0;
	}